name: Worker Agency Permission Grant
type: MyOS Admin Base
granteeDocumentId: # parent worker document id
  type: Text
allowedWorkerAgencyPermissions:
  type: List
  itemType: Worker Agency Permission
contracts:
  # Participants (channels)
  granterChannel:
    type: MyOS Timeline Channel
    description: Granter/ownerâ€™s timeline (actor allowed to request revoke)
  initLifecycleChannel:
    type: Lifecycle Event Channel
    event:
      type: Document Processing Initiated
  revoke:
    type: Operation
    description: Granter requests revocation (handled by MyOS Admin)
    channel: granterChannel
    request:
      type: Text
      description: Optional human-readable reason
  revokeImplGranter:
    type: Sequential Workflow Operation
    operation: revoke
    steps:
      - name: EmitRevokeRequested
        type: JavaScript Code
        code: |
          return {
            events: [
              {
                type: "Worker Agency Permission Revoke Requested",
                reason: event.message.request
              }
            ]
          };
  # --- Initial validation on first tick ---
  validateOnInit:
    type: Sequential Workflow
    channel: initLifecycleChannel
    steps:
      - name: ValidateBasicShape # TODO: review the implementation
        type: JavaScript Code
        code: |
          const issues = [];

          const unwrapText = value => {
            if (typeof value === 'string') {
              const trimmed = value.trim();
              return trimmed.length > 0 ? trimmed : undefined;
            }
            if (value && typeof value === 'object') {
              if (typeof value.value === 'string') {
                const trimmed = value.value.trim();
                return trimmed.length > 0 ? trimmed : undefined;
              }
              if (typeof value.workerType === 'string') {
                const trimmed = value.workerType.trim();
                return trimmed.length > 0 ? trimmed : undefined;
              }
              if (typeof value.name === 'string') {
                const trimmed = value.name.trim();
                return trimmed.length > 0 ? trimmed : undefined;
              }
            }
            return undefined;
          };

          const unwrapBoolean = value => {
            if (typeof value === 'boolean') {
              return value;
            }
            if (value && typeof value === 'object') {
              if (typeof value.value === 'boolean') {
                return value.value;
              }
              if (
                value.value &&
                typeof value.value === 'object' &&
                typeof value.value.value === 'boolean'
              ) {
                return value.value.value;
              }
            }
            return undefined;
          };

          const hasBooleanValue = value => {
            if (typeof value === 'boolean') {
              return true;
            }
            if (value && typeof value === 'object') {
              if (typeof value.value === 'boolean') {
                return true;
              }
              if (
                value.value &&
                typeof value.value === 'object' &&
                typeof value.value.value === 'boolean'
              ) {
                return true;
              }
            }
            return false;
          };

          const unwrapArray = value => {
            if (Array.isArray(value)) {
              return value;
            }
            if (value && typeof value === 'object' && Array.isArray(value.items)) {
              return value.items;
            }
            return [];
          };

          const unwrapRecord = value => {
            if (value && typeof value === 'object' && !Array.isArray(value)) {
              if (value.value && typeof value.value === 'object') {
                return value.value;
              }
              return value;
            }
            return {};
          };

          // --- granter binding (owner account) ---
          const granterId = document('/contracts/granterChannel/accountId');
          if (typeof granterId !== 'string' || granterId.length === 0) {
            issues.push("granterChannel must be bound to an accountId");
          }
          // --- grantee (parent worker) session id ---
          const granteeDocumentId = document('/granteeDocumentId');
          if (
            typeof granteeDocumentId !== 'string' ||
            granteeDocumentId.trim().length === 0
          ) {
            issues.push("granteeDocumentId must be a non-empty string");
          }
          // --- allowedWorkerAgencyPermissions : list of { workerType, permissions } ---
          const list = document('/allowedWorkerAgencyPermissions');
          if (!Array.isArray(list) || list.length === 0) {
            issues.push("allowedWorkerAgencyPermissions must be a non-empty array");
          } else {
            // helper: validate Single Document Permission Set
            const validateSDPS = (p, path) => {
              const record = unwrapRecord(p);
              if (Object.keys(record).length === 0) {
                issues.push(`${path} must be an object`);
                return;
              }
              // read must be true to allow any access at all
              const read = unwrapBoolean(record.read);
              if (read !== true) {
                issues.push(`${path}.read must be true`);
              }
              const share = record.share;
              const shareValue = unwrapBoolean(share);
              if (hasBooleanValue(share) && typeof shareValue !== 'boolean') {
                issues.push(`${path}.share must be boolean if provided`);
              }
              const allOps = record.allOps;
              const allOpsValue = unwrapBoolean(allOps);
              if (hasBooleanValue(allOps) && typeof allOpsValue !== 'boolean') {
                issues.push(`${path}.allOps must be boolean if provided`);
              }
              const singleOpsRaw = unwrapArray(record.singleOps)
                .map(entry => unwrapText(entry))
                .filter(Boolean);
              const hasSingle = singleOpsRaw.length > 0;
              if (hasSingle) {
                const bad = singleOpsRaw.length !== unwrapArray(record.singleOps).length;
                if (bad) issues.push(`${path}.singleOps must contain only non-empty strings`);
              }
              if (allOpsValue === true && hasSingle) {
                issues.push(`${path}.allOps=true and ${path}.singleOps are mutually exclusive`);
              }
              // Note: it is valid to have read=true with neither allOps nor singleOps (read-only template)
            };
            const seenTypes = new Set();
            list.forEach((item, idx) => {
              const itemPath = `/allowedWorkerAgencyPermissions[${idx}]`;
              // shape
              if (typeof item !== 'object' || item === null) {
                issues.push(`${itemPath} must be an object`);
                return;
              }
              // workerType
              const workerType = unwrapText(item.workerType);
              if (!workerType) {
                issues.push(`${itemPath}.workerType must be a non-empty string`);
              } else {
                if (seenTypes.has(workerType)) {
                  issues.push(`duplicate workerType '${workerType}' in allowedWorkerAgencyPermissions`);
                } else {
                  seenTypes.add(workerType);
                }
              }
              // permissions (Single Document Permission Set)
              const perms = item.permissions;
              if (typeof perms === 'undefined') {
                issues.push(`${itemPath}.permissions is required`);
              } else {
                validateSDPS(perms, `${itemPath}.permissions`);
              }
            });
          }
          if (issues.length > 0) {
            return { events: [ { type: "Worker Agency Permission Invalid", issues } ] };
          } else {
            return { events: [ { type: "Worker Agency Permission Validated" } ] };
          }
