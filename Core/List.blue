name: List
description: >
  Ordered collection (array) of elements.

  - Authoring & wrappers:
      detail: >
        Surface array (x: [a, b]) and wrapped form (x: { items: [a, b] }) are
        equivalent for authoring; canonical hashing uses the wrapped form
        (§8.2.2). The type itself does NOT declare `items`: `items` is the
        instance payload container. Declaring it on the type would install a
        concrete element array on the type object (a fixed invariant, §4.1) and
        conflate constraints with payload.

  - Order, multiplicity, identity:
      detail: >
        Order and multiplicity are preserved. List hashing is a domain-separated
        streaming fold over element BlueIds (§8.4). [A] ≠ A; [[] , A] ≠ [A].

  - Control item forms (reserved):
      detail: >
        Recognized only at the top level of items when the node’s type is List:
        $previous (append anchor), $pos (positional overlay), and $empty (content
        placeholder). $pos is consumed before hashing; $previous is an optimization
        seed only; $empty is content (§12.2–§12.6).

  - Present-empty vs absent & null cleaning:
      detail: >
        Present empty list [] is preserved and hashes differently from null or
        absent. Nulls inside items are removed during cleaning (§8.2.1, §8.2.2).

  - Uniqueness:
      detail: >
        uniqueItems compares by element BlueId (§5.2), not by textual rendering.

  - Merge policy:
      detail: >
        If `mergePolicy` is omitted, assume "positional" (§12.3). "append-only"
        forbids changes to the inherited prefix (no $pos); "positional" allows
        $pos overlays within the inherited prefix. Refinements must remain type-
        compatible with inherited elements (§4.2, §12.5).

  - Applicable schema:
      detail: >
        §5.2 list constraints: minItems, maxItems, uniqueItems.
itemType:
  description: >
    OPTIONAL. Type applied to each element. If omitted, elements are not
    constrained by itemType (still subject to overlays and type chain). Subtype
    compatibility MUST be preserved across refinements (§4.2, §12.5).
mergePolicy:
  type: Text
  description: >
    OPTIONAL. Authoring/merge policy. If omitted, processors MUST assume
    "positional" (§12.3). Allowed values: "append-only", "positional".
  schema:
    enum: [append-only, positional]
