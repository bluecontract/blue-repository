name: Single Document Permission Grant To Document
type: MyOS Admin Base

# ----------------- Document fields -----------------
targetSessionId:
  type: Text
  description: Target document session id to grant access to

granteeDocumentId:
  type: Text
  description: Required original document id (blueId) that will act as the grantee principal ('document')

granterDocumentSessionId:
  type: Text
  description: Optional. If set, MyOS should evaluate authority using this document session as the principal (instead of granter accountId).

permissions:
  type: Single Document Permission Set
  description: Rights to grant on the target session (READ required; allOps and singleOps are mutually exclusive; singleOps is optional but must be non-empty if provided).

# ---------- Contracts (participants, operations, workflows) ----------
contracts:
  # Participants (channels)
  granterChannel:
    type: MyOS Timeline Channel
    description: Granter/ownerâ€™s timeline (actor allowed to request revoke)

  initLifecycleChannel:
    type: Lifecycle Event Channel
    event:
      type: Document Processing Initiated

  revoke:
    type: Operation
    description: Granter requests revocation (handled by MyOS Admin)
    channel: granterChannel
    request:
      type: Text
      description: Optional human-readable reason

  revokeImplGranter:
    type: Sequential Workflow Operation
    operation: revoke
    steps:
      - name: EmitRevokeRequested
        type: JavaScript Code
        code: |
          return {
            events: [
              {
                type: "Single Document Permission Revoke Requested",
                reason: event.message.request
              }
            ]
          };

  # --- Initial validation on first tick ---
  validateOnInit:
    type: Sequential Workflow
    channel: initLifecycleChannel
    steps:
      - name: ValidateBasicShape
        type: JavaScript Code
        code: |
          const issues = [];

          // Required: target session
          const target = document('/targetSessionId');
          if (!target || typeof target !== 'string') issues.push("targetSessionId is missing or invalid");

          // Required: bound granter identity
          const granterId = document('/contracts/granterChannel/accountId');
          if (typeof granterId !== 'string' || granterId.length === 0) issues.push("granterChannel must be bound to an accountId");

          // Required: grantee document id
          const gdoc = document('/granteeDocumentId');
          if (typeof gdoc !== 'string' || gdoc.trim().length === 0) issues.push("granteeDocumentId must be a non-empty string (originalBlueId)");

          // Permissions
          const perms = document('/permissions');
          if (!perms || typeof perms !== 'object') {
            issues.push("permissions block is missing");
          } else {
            if (perms.read !== true) issues.push("permissions.read must be true for SDPG");
            const hasSingle = Object.prototype.hasOwnProperty.call(perms, 'singleOps');
            const isList = Array.isArray(perms?.singleOps);
            if (hasSingle) {
              if (!isList || perms.singleOps.length === 0) {
                issues.push("permissions.singleOps must be a non-empty list when provided");
              } else if (perms.singleOps.some(x => typeof x !== 'string' || x.trim().length === 0)) {
                issues.push("permissions.singleOps must contain only non-empty strings");
              }
            }
            if (perms.allOps === true && hasSingle) {
              issues.push("permissions.allOps=true and permissions.singleOps are mutually exclusive");
            }
          }

          if (issues.length > 0) return { events: [ { type: "Single Document Permission Invalid", issues } ] };
          return { events: [ { type: "Single Document Permission Validated" } ] };
