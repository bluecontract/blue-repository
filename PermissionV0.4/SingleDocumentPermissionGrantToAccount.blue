name: Single Document Permission Grant To Account
type: MyOS Admin Base

# ----------------- Document fields -----------------

targetSessionId:
  type: Text
  description: Target document session id to grant access to

granterDocumentSessionId:
  type: Text
  description: Optional. If set, MyOS should evaluate authority using this document session as the principal (instead of granter accountId).

permissions:
  type: Single Document Permission Set
  description: Rights to grant on the target session (READ required; allOps and singleOps are mutually exclusive; singleOps is optional but must be non-empty if provided).

# ---------- Contracts (participants, operations, workflows) ----------
contracts:
  # Participants (channels)
  granterChannel:
    type: MyOS Timeline Channel
    description: Granter/owner’s timeline (actor allowed to request revoke)

  granteeChannel:
    type: MyOS Timeline Channel
    description: Grantee’s timeline (recipient of the rights)

  initLifecycleChannel:
    type: Lifecycle Event Channel
    event:
      type: Document Processing Initiated

  revoke:
    type: Operation
    description: Granter or grantee indicates the grant should be revoked (MyOS Admin will handle)
    channel: granterChannel
    request:
      type: Text
      description: Optional human-readable reason

  revokeImplGranter:
    type: Sequential Workflow Operation
    operation: revoke
    steps:
      - name: EmitRevokeRequested
        type: JavaScript Code
        code: |
          return {
            events: [
              {
                type: "Single Document Permission Revoke Requested",
                reason: event.message.request
              }
            ]
          };

  # Currently each operation can only have one implementation
  # revokeImplGrantee:
  #   type: Sequential Workflow Operation
  #   description: Emit a revoke request event
  #   channel: granteeChannel
  #   operation: revoke
  #   steps:
  #     - name: EmitRevokeRequested
  #       type: JavaScript Code
  #       code: |
  #         return {
  #           events: [
  #             {
  #               type: "Single Document Permission Revoke Requested",
  #               reason: event.message.request
  #             }
  #           ]
  #         };

  # --- Initial validation on first tick ---
  validateOnInit:
    type: Sequential Workflow
    channel: initLifecycleChannel
    steps:
      - name: ValidateBasicShape
        type: JavaScript Code
        code: |
          const issues = [];

          // Required: target session
          const target = document('/targetSessionId');
          if (!target || typeof target !== 'string') issues.push("targetSessionId is missing or invalid");

          // Required: bound identities
          const granterId = document('/contracts/granterChannel/accountId');
          if (typeof granterId !== 'string' || granterId.length === 0) issues.push("granterChannel must be bound to an accountId");
          const granteeId = document('/contracts/granteeChannel/accountId');
          if (typeof granteeId !== 'string' || granteeId.length === 0) issues.push("granteeChannel must be bound to an accountId");

          // Permissions
          const perms = document('/permissions');
          if (!perms || typeof perms !== 'object') {
            issues.push("permissions block is missing");
          } else {
            if (perms.read !== true) issues.push("permissions.read must be true for SDPG");
            const hasSingle = Object.prototype.hasOwnProperty.call(perms, 'singleOps');
            const isList = Array.isArray(perms?.singleOps);
            if (hasSingle) {
              if (!isList || perms.singleOps.length === 0) {
                issues.push("permissions.singleOps must be a non-empty list when provided");
              } else if (perms.singleOps.some(x => typeof x !== 'string' || x.trim().length === 0)) {
                issues.push("permissions.singleOps must contain only non-empty strings");
              }
            }
            if (perms.allOps === true && hasSingle) {
              issues.push("permissions.allOps=true and permissions.singleOps are mutually exclusive");
            }
          }

          if (issues.length > 0) return { events: [ { type: "Single Document Permission Invalid", issues } ] };
          return { events: [ { type: "Single Document Permission Validated" } ] };
